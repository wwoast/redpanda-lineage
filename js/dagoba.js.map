{"version":3,"sources":["dagoba.js"],"names":["Dagoba","G","graph","V","E","Object","create","edges","vertices","vertexIndex","autoid","Array","isArray","addVertices","addEdges","v","query","add","slice","call","arguments","addVertex","vertex","_id","findVertexById","error","push","_out","_in","addEdge","edge","forEach","bind","removeVertex","removeEdge","remove","findVertices","args","searchVertices","length","findVerticesByIds","ids","maybe_vertex","map","filter","Boolean","vertex_id","objectFilter","findOutEdges","findInEdges","toString","jsonify","fromString","str","obj","parseJSON","Q","state","program","gremlins","run","transform","max","maybe_gremlin","results","done","pc","step","pipetype","getPipetype","gremlin","result","Pipetypes","addPipetype","name","fun","apply","fauxPipetype","pop","makeGremlin","simpleTraversal","dir","get_edges","find_method","other_side","filterEdges","concat","gotoVertex","limit","edgeList","current","taken","as","id","_label","indexOf","thing","key","cleanVertex","value","undefined","cleanEdge","JSON","stringify","parse","err","cloneflat","clone","persist","localStorage","setItem","depersist","flatgraph","getItem","msg","console","log","T","addTransformer","priority","i","splice","reduce","acc","transformer","addAlias","newname","newprogram","extend","list","defaults","keys","item"],"mappings":"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","file":"dagoba.js","sourcesContent":["/*\n     ____  _____ _____ _____ _____ _____\n    |    \\|  _  |   __|     | __  |  _  |\n    |  |  |     |  |  |  |  | __ -|     |\n    |____/|__|__|_____|_____|_____|__|__|\n\n    dagoba: a tiny in-memory graph database\n\n    ex:\n    V = [ {name: 'alice'}                                         // alice gets auto-_id (prolly 1)\n        , {_id: 10, name: 'bob', hobbies: ['asdf', {x:3}]}]\n    E = [ {_out: 1, _in: 10, _label: 'knows'} ]\n    g = Dagoba.graph(V, E)\n\n    g.addVertex({name: 'charlie', _id: 'charlie'})                // string ids are fine\n    g.addVertex({name: 'delta', _id: '30'})                       // in fact they're all strings\n\n    g.addEdge({_out: 10, _in: 30, _label: 'parent'})\n    g.addEdge({_out: 10, _in: 'charlie', _label: 'knows'})\n\n    g.v(1).out('knows').out().run()                               // returns [charlie, delta]\n\n    q = g.v(1).out('knows').out().take(1)\n    q.run()                                                       // returns [charlie]\n    q.run()                                                       // returns [delta]    (but don't rely on result order!)\n    q.run()                                                       // returns []\n\n\n    Dagoba consists of two main parts: graphs and queries.\n    A graph contains vertices and edges, and provides access to query initializers like g.v()\n    A query contains pipes, which make up a pipeline, and a virtual machine for processing pipelines.\n    There are some pipe types defined by default.\n    There are also a few helper functions.\n    That's all.\n\n\n    copyright dann toliver, 2015\n    version 0.3.4\n*/\n\n\nvar Dagoba = {}                                                   // the namespace\n\nDagoba.G = {}                                                     // the prototype\n\nDagoba.graph = function(V, E) {                                   // the factory\n  var graph = Object.create( Dagoba.G )\n  graph.edges       = []                                          // fresh copies so they're not shared\n  graph.vertices    = []\n  graph.vertexIndex = {}\n  graph.autoid = 1                                                // an auto-incrementing id counter\n  if(Array.isArray(V)) graph.addVertices(V)                       // arrays only, because you wouldn't\n  if(Array.isArray(E)) graph.addEdges(E)                          // call this with singular V and E\n  return graph\n}\n\nDagoba.G.v = function() {                                         // a query initializer: g.v() -> query\n  var query = Dagoba.query(this)\n  query.add('vertex', [].slice.call(arguments))                   // add vertex as first query pipe\n  return query\n}\n\nDagoba.G.addVertex = function(vertex) {                           // accepts a vertex-like object, with properties\n  if(vertex._id >= this.autoid)\n    this.autoid = vertex._id + 1                                  // ensure autoid doesn't overwrite\n  if(!vertex._id)\n    vertex._id = this.autoid++\n  else if(this.findVertexById(vertex._id))\n    return Dagoba.error('A vertex with id ' + vertex._id + ' already exists')\n\n  this.vertices.push(vertex)\n  this.vertexIndex[vertex._id] = vertex\n  vertex._out = []; vertex._in = []                               // placeholders for edge pointers\n  return vertex._id\n}\n\nDagoba.G.addEdge = function(edge) {                               // accepts an edge-like object, with properties\n  edge._in  = this.findVertexById(edge._in)\n  edge._out = this.findVertexById(edge._out)\n\n  if(!(edge._in && edge._out))\n    return Dagoba.error(\"That edge's \" + (edge._in ? 'out' : 'in') + \" vertex wasn't found\")\n\n  edge._out._out.push(edge)                                       // add edge to the edge's out vertex's out edges\n  edge._in._in.push(edge)                                         // vice versa\n  this.edges.push(edge)\n}\n\nDagoba.G.addVertices = function(vertices) { vertices.forEach(this.addVertex.bind(this)) }\nDagoba.G.addEdges    = function(edges)    { edges   .forEach(this.addEdge  .bind(this)) }\n\nDagoba.G.removeVertex = function(vertex) {\n  vertex._in .slice().forEach(Dagoba.G.removeEdge.bind(this))\n  vertex._out.slice().forEach(Dagoba.G.removeEdge.bind(this))\n  Dagoba.remove(this.vertices, vertex)\n  delete this.vertexIndex[vertex._id]\n}\n\nDagoba.G.removeEdge = function(edge) {\n  Dagoba.remove(edge._in._in, edge)\n  Dagoba.remove(edge._out._out, edge)\n  Dagoba.remove(this.edges, edge)\n}\n\nDagoba.G.findVertices = function(args) {                          // our general vertex finding function\n  if(typeof args[0] == 'object')\n    return this.searchVertices(args[0])\n  else if(args.length == 0)\n    return this.vertices.slice()                                  // OPT: slice is costly with lots of vertices\n  else\n    return this.findVerticesByIds(args)\n}\n\n// Dagoba.G.findVertices = function(ids) {                           // our general vertex finding function\n//   return typeof ids[0] == 'object' ? this.searchVertices(ids[0])\n//        : ids.length == 0 ? this.vertices.slice()                  // OPT: slice is costly with lots of vertices\n//        : this.findVerticesByIds(ids) }\n\nDagoba.G.findVerticesByIds = function(ids) {\n  if(ids.length == 1) {\n    var maybe_vertex = this.findVertexById(ids[0])                // maybe_vertex is either a vertex or undefined\n    return maybe_vertex ? [maybe_vertex] : []\n  }\n\n  return ids.map( this.findVertexById.bind(this) ).filter(Boolean)\n}\n\n// Dagoba.G.findVerticesByIds = function(ids) {\n//   return ids.length == 1\n//          ? [].concat( this.findVertexById(ids[0]) || [] )\n//          : ids.map( this.findVertexById.bind(this) ).filter(Boolean) }\n\nDagoba.G.findVertexById = function(vertex_id) {\n  return this.vertexIndex[vertex_id]\n}\n\nDagoba.G.searchVertices = function(filter) {                      // find vertices that match obj's key-value pairs\n  return this.vertices.filter(function(vertex) {\n    return Dagoba.objectFilter(vertex, filter)\n  })\n}\n\n// Dagoba.G.searchVertices = function(obj) {                         // find vertices that match obj's key-value pairs\n//   return this.vertices.filter(\n//     function(vertex) {\n//       return Object.keys(obj).reduce(\n//         function(acc, key) {\n//           return acc && obj[key] == vertex[key] }, true ) } ) }\n\nDagoba.G.findOutEdges = function(vertex) { return vertex._out; }\nDagoba.G.findInEdges  = function(vertex) { return vertex._in;  }\n\nDagoba.G.toString = function() { return Dagoba.jsonify(this) }    // serialization\n\nDagoba.fromString = function(str) {                               // another graph constructor\n  var obj = Dagoba.parseJSON(str)                                 // this could throw\n  if(!obj) return null\n  return Dagoba.graph(obj.V, obj.E)\n}\n\n\n\nDagoba.Q = {}                                                     // prototype\n\nDagoba.query = function(graph) {                                  // factory (only called by a graph's query initializers)\n  var query = Object.create( Dagoba.Q )\n\n  query.   graph = graph                                          // the graph itself\n  query.   state = []                                             // state for each step\n  query. program = []                                             // list of steps to take\n  query.gremlins = []                                             // gremlins for each step\n\n  return query\n}\n\nDagoba.Q.run = function() {                                       // our virtual machine for query processing\n  this.program = Dagoba.transform(this.program)                   // activate the transformers\n\n  var max = this.program.length - 1                               // last step in the program\n  var maybe_gremlin = false                                       // a gremlin, a signal string, or false\n  var results = []                                                // results for this particular run\n  var done = -1                                                   // behindwhich things have finished\n  var pc = max                                                    // our program counter -- we start from the end\n\n  var step, state, pipetype\n\n  // driver loop\n  while(done < max) {\n\n    step = this.program[pc]                                       // step is an array: first the pipe type, then its args\n    state = (this.state[pc] = this.state[pc] || {})               // the state for this step: ensure it's always an object\n    pipetype = Dagoba.getPipetype(step[0])                        // a pipetype is just a function\n\n    maybe_gremlin = pipetype(this.graph, step[1], maybe_gremlin, state)\n\n    if(maybe_gremlin == 'pull') {                                 // 'pull' tells us the pipe wants further input\n      maybe_gremlin = false\n      if(pc-1 > done) {\n        pc--                                                      // try the previous pipe\n        continue\n      } else {\n        done = pc                                                 // previous pipe is finished, so we are too\n      }\n    }\n\n    if(maybe_gremlin == 'done') {                                 // 'done' tells us the pipe is finished\n      maybe_gremlin = false\n      done = pc\n    }\n\n    pc++                                                          // move on to the next pipe\n\n    if(pc > max) {\n      if(maybe_gremlin)\n        results.push(maybe_gremlin)                               // a gremlin popped out the end of the pipeline\n      maybe_gremlin = false\n      pc--                                                        // take a step back\n    }\n  }\n\n  results = results.map(function(gremlin) {                       // return either results (like property('name')) or vertices\n    return gremlin.result != null\n         ? gremlin.result : gremlin.vertex } )\n\n  return results\n}\n\n\nDagoba.Q.add = function(pipetype, args) {                         // add a new step to the query\n  var step = [pipetype, args]\n  this.program.push(step)                                         // step is an array: first the pipe type, then its args\n  return this\n}\n\nDagoba.Pipetypes = {}                                             // every pipe has a type\n\nDagoba.addPipetype = function(name, fun) {                        // adds a new method to our query object\n  Dagoba.Pipetypes[name] = fun\n  Dagoba.Q[name] = function() {\n    return this.add(name, [].slice.apply(arguments)) }            // capture the pipetype and args\n}\n\nDagoba.getPipetype = function(name) {\n  var pipetype = Dagoba.Pipetypes[name]                           // a pipe type is just a function\n\n  if(!pipetype)\n    Dagoba.error('Unrecognized pipe type: ' + name)\n\n  return pipetype || Dagoba.fauxPipetype\n}\n\nDagoba.fauxPipetype = function(graph, args, maybe_gremlin) {      // if you can't find a pipe type\n  return maybe_gremlin || 'pull'                                  // just keep things flowing along\n}\n\n// BUILT-IN PIPE TYPES\n\n\nDagoba.addPipetype('vertex', function(graph, args, gremlin, state) {\n  if(!state.vertices)\n    state.vertices = graph.findVertices(args)                     // state initialization\n\n  if(!state.vertices.length)                                      // all done\n    return 'done'\n\n  var vertex = state.vertices.pop()                               // OPT: this relies on cloning the vertices\n  return Dagoba.makeGremlin(vertex, gremlin.state)                // we can have incoming gremlins from as/back queries\n})\n\nDagoba.simpleTraversal = function(dir) {                          // handles basic in, out and both pipetypes\n\n  function get_edges(graph, dir, vertex, filter) {                // get edges that match our query\n    var find_method = dir === 'out' ? 'findOutEdges' : 'findInEdges'\n    var other_side  = dir === 'out' ? '_in' : '_out'\n\n    return graph[find_method](vertex)\n      .filter(Dagoba.filterEdges(filter))\n      .map(function(edge) { return edge[other_side] })\n  }\n\n  return function(graph, args, gremlin, state) {\n    if(!gremlin && (!state.edges || !state.edges.length))         // query initialization\n      return 'pull'\n\n    if(!state.edges || !state.edges.length) {                     // state initialization\n      state.gremlin = gremlin\n      state.edges = get_edges(graph, dir, gremlin.vertex, args[0])\n\n      if(dir === 'both')\n        state.edges = state.edges.concat(\n          get_edges(graph, 'out', gremlin.vertex, args[0]))\n    }\n\n    if(!state.edges.length)                                       // all done\n      return 'pull'\n\n    var vertex = state.edges.pop()                                // use up an edge\n    return Dagoba.gotoVertex(state.gremlin, vertex)\n  }\n}\n\nDagoba.addPipetype('in',   Dagoba.simpleTraversal('in'))\nDagoba.addPipetype('out',  Dagoba.simpleTraversal('out'))\nDagoba.addPipetype('both', Dagoba.simpleTraversal('both'))\n\n\nDagoba.addPipetype('outAllN', function(graph, args, gremlin, state) {\n\n  //// THIS PIPETYPE IS GOING AWAY DON'T READ IT\n\n  var filter = args[0]\n  var limit = args[1]-1\n\n  if(!state.edgeList) {                                           // initialize\n    if(!gremlin) return 'pull'\n    state.edgeList = []\n    state.current = 0\n    state.edgeList[0] = graph.findOutEdges(gremlin.vertex).filter(Dagoba.filterEdges(filter))\n  }\n\n  if(!state.edgeList[state.current].length) {                     // finished this round\n    if(state.current >= limit || !state.edgeList[state.current+1] // totally done, or the next round has no items\n                              || !state.edgeList[state.current+1].length) {\n      state.edgeList = false\n      return 'pull'\n    }\n    state.current++                                               // go to next round\n    state.edgeList[state.current+1] = []\n  }\n\n  var vertex = state.edgeList[state.current].pop()._in\n\n  if(state.current < limit) {                                     // add all our matching edges to the next level\n    if(!state.edgeList[state.current+1]) state.edgeList[state.current+1] = []\n    state.edgeList[state.current+1] = state.edgeList[state.current+1].concat(\n      graph.findOutEdges(vertex).filter(Dagoba.filterEdges(filter))\n    )\n  }\n\n  return Dagoba.gotoVertex(gremlin, vertex)\n})\n\nDagoba.addPipetype('inAllN', function(graph, args, gremlin, state) {\n\n  //// THIS PIPETYPE IS GOING AWAY DON'T READ IT\n\n  var filter = args[0]\n  var limit = args[1]-1\n\n  if(!state.edgeList) {                                           // initialize\n    if(!gremlin) return 'pull'\n    state.edgeList = []\n    state.current = 0\n    state.edgeList[0] = graph.findInEdges(gremlin.vertex).filter(Dagoba.filterEdges(filter))\n  }\n\n  if(!state.edgeList[state.current].length) {                     // finished this round\n    if(state.current >= limit || !state.edgeList[state.current+1] // totally done, or the next round has no items\n                              || !state.edgeList[state.current+1].length) {\n      state.edgeList = false\n      return 'pull'\n    }\n    state.current++                                               // go to next round\n    state.edgeList[state.current+1] = []\n  }\n\n  var vertex = state.edgeList[state.current].pop()._out\n\n  if(state.current < limit) {                                     // add all our matching edges to the next level\n    if(!state.edgeList[state.current+1]) state.edgeList[state.current+1] = []\n    state.edgeList[state.current+1] = state.edgeList[state.current+1].concat(\n      graph.findInEdges(vertex).filter(Dagoba.filterEdges(filter))\n    )\n  }\n\n  return Dagoba.gotoVertex(gremlin.state, vertex)\n})\n\nDagoba.addPipetype('property', function(graph, args, gremlin, state) {\n  if(!gremlin) return 'pull'                                      // query initialization\n  gremlin.result = gremlin.vertex[args[0]]\n  return gremlin.result == null ? false : gremlin                 // undefined or null properties kill the gremlin\n})\n\nDagoba.addPipetype('unique', function(graph, args, gremlin, state) {\n  if(!gremlin) return 'pull'                                      // query initialization\n  if(state[gremlin.vertex._id]) return 'pull'                     // we've seen this gremlin, so get another instead\n  state[gremlin.vertex._id] = true\n  return gremlin\n})\n\nDagoba.addPipetype('filter', function(graph, args, gremlin, state) {\n  if(!gremlin) return 'pull'                                      // query initialization\n\n  if(typeof args[0] == 'object')                                  // filter by object\n    return Dagoba.objectFilter(gremlin.vertex, args[0])\n         ? gremlin : 'pull'\n\n  if(typeof args[0] != 'function') {\n    Dagoba.error('Filter arg is not a function: ' + args[0])\n    return gremlin                                                // keep things moving\n  }\n\n  if(!args[0](gremlin.vertex, gremlin)) return 'pull'             // gremlin fails filter function\n  return gremlin\n})\n\nDagoba.addPipetype('take', function(graph, args, gremlin, state) {\n  state.taken = state.taken || 0                                  // state initialization\n\n  if(state.taken == args[0]) {\n    state.taken = 0\n    return 'done'                                                 // all done\n  }\n\n  if(!gremlin) return 'pull'                                      // query initialization\n  state.taken++                                                   // THINK: if this didn't mutate state, we could be more\n  return gremlin                                                  // cavalier about state management (but run the GC hotter)\n})\n\nDagoba.addPipetype('as', function(graph, args, gremlin, state) {\n  if(!gremlin) return 'pull'                                      // query initialization\n  gremlin.state.as = gremlin.state.as || {}                       // initialize gremlin's 'as' state\n  gremlin.state.as[args[0]] = gremlin.vertex                      // set label to the current vertex\n  return gremlin\n})\n\nDagoba.addPipetype('back', function(graph, args, gremlin, state) {\n  if(!gremlin) return 'pull'                                      // query initialization\n  return Dagoba.gotoVertex(gremlin, gremlin.state.as[args[0]])    // TODO: check for nulls\n})\n\nDagoba.addPipetype('except', function(graph, args, gremlin, state) {\n  if(!gremlin) return 'pull'                                      // query initialization\n  if(gremlin.vertex == gremlin.state.as[args[0]]) return 'pull'   // TODO: check for nulls\n  return gremlin\n})\n\nDagoba.addPipetype('merge', function(graph, args, gremlin, state) {\n  //// THINK: merge and back are very similar...\n  if(!state.vertices && !gremlin) return 'pull'                   // query initialization\n\n  if(!state.vertices || !state.vertices.length) {                 // state initialization\n    var obj = (gremlin.state||{}).as || {}\n    state.vertices = args.map(function(id) {return obj[id]}).filter(Boolean)\n  }\n\n  if(!state.vertices.length) return 'pull'                        // done with this batch\n\n  var vertex = state.vertices.pop()\n  return Dagoba.makeGremlin(vertex, gremlin.state)\n})\n\n\n// HELPER FUNCTIONS\n\nDagoba.makeGremlin = function(vertex, state) {                    // gremlins are simple creatures:\n  return {vertex: vertex, state: state || {} }                    // a current vertex, and some state\n}\n\nDagoba.gotoVertex = function(gremlin, vertex) {                   // clone the gremlin\n  return Dagoba.makeGremlin(vertex, gremlin.state)                // THINK: add path tracking here?\n}\n\nDagoba.filterEdges = function(filter) {\n  return function(edge) {\n    if(!filter)                                                   // if there's no filter, everything is valid\n      return true\n\n    if(typeof filter == 'string')                                 // if the filter is a string, the label must match\n      return edge._label == filter\n\n    if(Array.isArray(filter))                                     // if the filter is an array, the label must be in it\n      return !!~filter.indexOf(edge._label)\n\n    return Dagoba.objectFilter(edge, filter)                      // try the filter as an object\n  }\n}\n// Dagoba.filterEdges = function(arg) {\n//   return function(thing) {\n//     return !arg ? true                                            // nothing is true\n//          : arg+'' === arg ? thing._label == arg                   // check the label\n//          : Array.isArray(arg) ? !!~arg.indexOf(thing._label)      // or a list of labels\n//          : Dagoba.objectFilter(thing, arg) } }                    // try it as an object\n\nDagoba.objectFilter = function(thing, filter) {                   // thing has to match all of filter's properties\n  for(var key in filter)\n    if(thing[key] !== filter[key])\n      return false\n\n  return true\n}\n\nDagoba.cleanVertex = function(key, value) {                       // for JSON.stringify\n  return (key == '_in' || key == '_out') ? undefined : value\n}\n\nDagoba.cleanEdge = function(key, value) {\n  return (key == '_in' || key == '_out') ? value._id : value\n}\n\nDagoba.jsonify = function(graph) {                                // kids, don't hand code JSON\n  return '{\"V\":' + JSON.stringify(graph.vertices, Dagoba.cleanVertex)\n       + ',\"E\":' + JSON.stringify(graph.edges,    Dagoba.cleanEdge)\n       + '}'\n}\n\nDagoba.parseJSON = function(str) {\n  try {\n    return JSON.parse(str)\n  } catch(err) {\n    Dagoba.error('Invalid JSON', err)\n    return null\n  }\n}\n\nDagoba.cloneflat = function(graph) {\n  return Dagoba.parseJSON(Dagoba.jsonify(graph))\n}\n\nDagoba.clone = function(graph) {\n  var G = Dagoba.cloneflat(graph)\n  return Dagoba.graph(G.V, G.E)\n}\n\nDagoba.persist = function(graph, name) {\n  name = name || 'graph'\n  localStorage.setItem('DAGOBA::'+name, graph)\n}\n\nDagoba.depersist = function (name) {\n  name = 'DAGOBA::' + (name || 'graph')\n  var flatgraph = localStorage.getItem(name)\n  return Dagoba.fromString(flatgraph)\n}\n\nDagoba.error = function(msg) {\n  console.log(msg)\n  return false\n}\n\n\nDagoba.T = []                                                     // transformers (more than meets the eye)\n\nDagoba.addTransformer = function(fun, priority) {\n  if(typeof fun != 'function')\n    return Dagoba.error('Invalid transformer function')\n\n  for(var i = 0; i < Dagoba.T.length; i++)                        // OPT: binary search\n    if(priority > Dagoba.T[i].priority) break\n\n  Dagoba.T.splice(i, 0, {priority: priority, fun: fun})\n}\n\nDagoba.transform = function(program) {\n  return Dagoba.T.reduce(function(acc, transformer) {\n    return transformer.fun(acc)\n  }, program)\n}\n\n\nDagoba.addAlias = function(newname, newprogram) {\n  Dagoba.addPipetype(newname, function() {})                      // because there's no method catchall in js\n  newprogram = newprogram.map(function(step) {\n    return [step[0], step.slice(1)]                               // [['out', 'parent']] => [['out', ['parent']]]\n  })\n  // defaults = defaults || []                                    // default arguments for the alias\n  Dagoba.addTransformer(function(program) {\n    return program.reduce(function(acc, step) {\n      if(step[0] != newname) return acc.concat([step])\n      return acc.concat(newprogram)\n    }, [])\n    // return program.map(function(step) {\n    //   if(step[0] != newname) return step\n    //   return [oldname, Dagoba.extend(step[1], defaults)]       // THINK: we need a way to thread alias params through\n    // })\n  }, 100)                                                         // these need to run early, so they get a high priority\n}\n\nDagoba.extend = function(list, defaults) {\n  return Object.keys(defaults).reduce(function(acc, key) {\n    if(typeof list[key] != 'undefined') return acc\n    acc[key] = defaults[key]\n    return acc\n  }, list)\n}\n\nDagoba.remove = function(list, item) {\n  return list.splice(list.indexOf(item), 1)\n}\n\n// more todos\n// - tune gremlins (collisions, history, etc)\n// - interface: show query pieces and params,\n// - interface: resumable queries\n// - generational queries\n// - intersections\n// - adverbs\n\n// TODO: show how to refactor 'out', 'outN', and 'outAllN' using adverbs. also the 'in' equivalents. also make adverbs.\n// TODO: deal with gremlin paths / history and gremlin \"collisions\"\n// THINK: the user may retain a pointer to vertex, which they might mutate later >.<\n// can take away user's ability to set _id and lose the index cache hash, because building it causes big rebalancing slowdowns and runs the GC hard. (or does it?) [this was with a million items, indexed by consecutive ints. generally we need settable _id because we need to grab vertices quickly by external key]\n\n\n/*\n        ---> no edge _id stuff\n        ---> simplify driver loop helpers\n        ---> refactor outAllN etc (mmm but adverbs?)\n        ---> leo's queries !\n*/\n\n\n// re: Dagoba.Q.addPipetype\n// TODO: accept string fun and allow extra params, for building quick aliases like\n//       Dagoba.addPipetype('children', 'out') <-- if all out edges are kids\n//       Dagoba.addPipetype('nthGGP', 'inN', 'parent')\n// var methods = ['out', 'in', 'take', 'property', 'outAllN', 'inAllN', 'unique', 'filter', 'outV', 'outE', 'inV', 'inE', 'both', 'bothV', 'bothE']\n\n\n// what if instead of mutating the query object for each new 'method' we create a new one? then you can have something like\n// x = G.v(1).out().out()\n// q = x.take(1)\n// y = x.take(10)\n// and it will do what you want instead of exploding.\n\n// or....\n// x = g.v(1).out().out()\n// y = D.clone(x).take(1)\n// x.take(1).run()\n// y.run() // same answer\n"]}